#' TrialsPerStim Function
#'
#' This function processes behavioral data files generated by the Davis Rig apparatus, typically stored as .txt files.
#' The function reads the content of the files, extracts metadata such as Animal ID and Start Date, and processes the main data section to compute summary statistics.
#' It counts the number of trials for each unique concentration-stimulus combination where the number of licks is greater than zero, and it also counts the number of uninitiated trials (trials with 0 licks) across all trials up to the last initiated trial.
#' The results are returned as a structured dataframe, and the combined results are saved to the global environment as 'result'.
#'
#' @param path A string specifying the path to a directory containing multiple .txt files or a single .txt file.
#' 
#' @return A dataframe with the following columns:
#'   - Animal_id: The ID of the animal from the metadata.
#'   - Date: The start date of the experiment from the metadata.
#'   - Num_trials: The number of trials, defined as the PRESENTATION number of the first trial with a latency of 0, or the maximum PRESENTATION number if no such trial exists.
#'   - Total_Licks: The total number of licks across all trials.
#'   - Uninitiated: The number of trials with 0 licks across all trials, up to `Num_trials`.
#'   - Dynamic columns representing the count of trials for each unique concentration-stimulus combination where LICKS > 0.
#' 
#' The function also saves the result to the global environment as 'result'.
#' 
#' @examples
#' # Process a single file
#' TrialsPerStim("C:/DavisData/0719test.ms8.txt")
#' 
#' # Process all files in a directory
#' TrialsPerStim("C:/DavisData/")
#' 
#' @import dplyr
#' 
#' @export
#' 
#' Author: Kolbe Sussman
#' Email: ksussman@emich.edu
#' Updated: 8/15/24
#' 

TrialsPerStim <- function(path) {
  # Load necessary library
  library(dplyr)
  
  # Function to process a single file
  process_file <- function(file_path) {
    # Read in the .txt file as a single string
    file_content <- readLines(file_path, warn = FALSE)
    text <- paste(file_content, collapse = "\n")
    
    # Split the text based on the word "PRESENTATION"
    split_text <- strsplit(text, "PRESENTATION", fixed = TRUE)[[1]]
    
    # Assign the text before and including "PRESENTATION" to META
    META <- split_text[1]
    
    # Function to extract value by key
    extract_value <- function(text, key) {
      # Create a pattern to match the key and extract the value
      pattern <- paste0(key, ",\\s*(.*)")
      matches <- regmatches(text, regexpr(pattern, text, perl = TRUE))
      # Extract the value from the match
      if (length(matches) > 0) {
        return(sub(pattern, "\\1", matches))
      } else {
        return(NA)
      }
    }
    
    # Extract Animal ID and Start Date
    animal_id <- extract_value(META, "Animal ID")
    date <- extract_value(META, "Start Date")
    
    # Assign the text including and after "PRESENTATION" to DATA
    DATA <- paste("PRESENTATION", split_text[2], sep = " ")
    
    # Split DATA on an empty line
    data_split <- strsplit(DATA, "\n\n")[[1]]
    
    # Assign text before the empty line to DATA
    DATA <- data_split[1]
    
    # Split DATA into lines
    data_lines <- strsplit(DATA, "\n")[[1]]
    
    # Create a text connection object from the string
    text_conn <- textConnection(DATA)
    
    # Read the data from the text connection into a dataframe
    temp_data <- read.csv(text_conn, header = TRUE)
    
    # Close the text connection
    close(text_conn)
    
    # Define num_trials as the PRESENTATION number for the first line in DATA where Latency == 0
    zero_latency_rows <- temp_data %>%
      filter(Latency == 0)
    
    if (nrow(zero_latency_rows) > 0) {
      num_trials <- zero_latency_rows %>%
        slice(1) %>%
        pull(PRESENTATION)
    } else {
      num_trials <- max(temp_data$PRESENTATION, na.rm = TRUE)
    }
    
    # Filter the data up to num_trials
    filtered_data <- temp_data %>%
      filter(PRESENTATION <= num_trials)
    
    # Combine CONCENTRATION and STIMULUS into a new column
    filtered_data <- filtered_data %>%
      mutate(CONC_STIM = paste(CONCENTRATION, SOLUTION))
    
    # Count the number of trials for each unique CONC_STIM combination where LICKS > 0
    trials_per_stim <- filtered_data %>%
      filter(LICKS > 0) %>%
      group_by(CONC_STIM) %>%
      summarise(TRIALS_COUNT = n())
    
    # Count the number of uninitiated trials (LICKS == 0) across all trials up to num_trials
    uninitiated_trials <- sum(filtered_data$LICKS == 0, na.rm = TRUE)
    
    # Calculate the total number of LICKS
    total_licks <- sum(filtered_data$LICKS, na.rm = TRUE)
    
    # Create a new dataframe with the desired structure
    result <- data.frame(
      Animal_id = animal_id,
      Date = date,
      Num_trials = num_trials,
      Total_Licks = total_licks,
      Uninitiated = uninitiated_trials,
      t(trials_per_stim$TRIALS_COUNT)
    )
    
    # Set column names
    colnames(result) <- c("Animal_id", "Date", "Num_trials", "Total_Licks", "Uninitiated", as.character(trials_per_stim$CONC_STIM))
    
    return(result)
  }
  
  # Check if the path is a directory
  if (dir.exists(path)) {
    file_paths <- list.files(path, pattern = "\\.txt$", full.names = TRUE)
  } else if (file.exists(path)) {
    file_paths <- path
  } else {
    stop("The provided path does not exist.")
  }
  
  # Initialize an empty list to store results
  results <- list()
  
  # Process each file and store results
  if (length(file_paths) > 1) {
    for (file_path in file_paths) {
      results[[file_path]] <- process_file(file_path)
    }
    
    # Combine all results into a single dataframe
    combined_results <- bind_rows(results, .id = "file") %>%
      select(-file)  # Remove the file column if needed
  } else {
    combined_results <- process_file(file_paths)
  }
  
  # Save the combined results to the global environment
  assign("TrialNumResult", combined_results, envir = .GlobalEnv)
  
  # Print a message and return the combined results
  cat("Data has been processed and saved to the global environment as 'result'.\n")
  return(combined_results)
}
