#' AverageILIPerStim Function
#'
#' This function processes behavioral data files generated by experimental protocols, specifically those related to inter-lick interval (ILI) measurements. 
#' The function reads in the content of the files, extracts metadata such as Animal ID and Start Date, and processes the main data section to compute the average ILI for each unique concentration-stimulus combination.
#' The results are returned as a structured dataframe, and the combined results are saved to the global environment as 'AveResult'.
#'
#' @param path A string specifying the path to a directory containing multiple .txt files or a single .txt file.
#' 
#' @return A dataframe with the following columns:
#'   - Animal_id: The ID of the animal from the metadata.
#'   - Date: The start date of the experiment from the metadata.
#'   - Num_trials: The number of trials, defined as the PRESENTATION number of the first trial with a latency of 0, or the maximum PRESENTATION number if no such trial exists.
#'   - Dynamic columns representing the average ILI for each unique concentration-stimulus combination where ILI > 0.
#' 
#' The function also saves the result to the global environment as 'AveResult'.
#' 
#' @examples
#' # Process a single file
#' AverageILIPerStim("C:/DavisData/0719test.ms8.txt")
#' 
#' # Process all files in a directory
#' AverageILIPerStim("C:/DavisData/")
#' 
#' @import dplyr
#' 
#' @export
#' 
#' Author: Kolbe Sussman
#' Email: ksussman@emich.edu
#' Updated: 8/16/24

AverageILIPerStim <- function(path) {
  # Load necessary library
  library(dplyr)
  
  # Function to process a single file
  process_file <- function(file_path) {
    # Read in the .txt file as a single string
    file_content <- readLines(file_path, warn = FALSE)
    text <- paste(file_content, collapse = "\n")
    
    # Split the text based on the word "PRESENTATION"
    split_text <- strsplit(text, "PRESENTATION", fixed = TRUE)[[1]]
    
    # Assign the text before and including "PRESENTATION" to META
    META <- split_text[1]
    
    # Function to extract value by key
    extract_value <- function(text, key) {
      # Create a pattern to match the key and extract the value
      pattern <- paste0(key, ",\\s*(.*)")
      matches <- regmatches(text, regexpr(pattern, text, perl = TRUE))
      # Extract the value from the match
      if (length(matches) > 0) {
        return(sub(pattern, "\\1", matches))
      } else {
        return(NA)
      }
    }
    
    # Extract Animal ID and Start Date
    animal_id <- extract_value(META, "Animal ID")
    date <- extract_value(META, "Start Date")
    
    # Assign the text including and after "PRESENTATION" to DATA
    DATA <- paste("PRESENTATION", split_text[2], sep = " ")
    
    # Split DATA on an empty line
    data_split <- strsplit(DATA, "\n\n")[[1]]
    
    # Assign text before the empty line to DATA
    DATA <- data_split[1]
    TIME <- data_split[2]
    
    # Split DATA into lines
    data_lines <- strsplit(DATA, "\n")[[1]]
    
    # Create a text connection object from the string
    text_conn <- textConnection(DATA)
    
    # Read the data from the text connection into a dataframe
    temp_data <- read.csv(text_conn, header = TRUE)
    
    # Close the text connection
    close(text_conn)
    
    # Define num_trials as the PRESENTATION number for the first line in DATA where Latency == 0
    zero_latency_rows <- temp_data %>%
      filter(Latency == 0)
    
    if (nrow(zero_latency_rows) > 0) {
      num_trials <- zero_latency_rows %>%
        slice(1) %>%
        pull(PRESENTATION)
    } else {
      num_trials <- max(temp_data$PRESENTATION, na.rm = TRUE)
    }
    temp_data <- temp_data[1:num_trials, ]
    # Combine CONCENTRATION and STIMULUS into a new column
    temp_data <- temp_data %>%
      mutate(CONC_STIM = paste(CONCENTRATION, SOLUTION))
    
    # Calculate the average ILI from TIME and save in list
    ILIs <- list()
    time_lines <- strsplit(TIME, "\n")[[1]]
    
    # Loop over each line in TIME, but only for lines 1-40
    for (i in 1:min(num_trials, length(time_lines))) {
      # Extract the line
      line <- time_lines[i]
      
      # Split the line into individual numbers (as strings)
      line_split <- as.numeric(unlist(strsplit(line, ",")))
      
      # Calculate the average ILI (ignoring the first element which is the presentation number)
      aveILI <- mean(line_split[-1])
      
      # Append the average ILI to the ILIs list
      ILIs <- append(ILIs, aveILI)
    }
    
    # Add the list as a new column to the data frame
    temp_data$ILI <- unlist(ILIs)
    
    # Calculate the average ILI for each unique CONC_STIM combination where ILI > 0
    avg_ILI <- temp_data %>%
      filter(ILI > 0) %>%
      group_by(CONC_STIM) %>%
      summarise(AVERAGE_ILI = mean(ILI, na.rm = TRUE))
    
    # Create a new dataframe with the desired structure
    result <- data.frame(
      Animal_id = animal_id,
      Date = date,
      Num_trials = num_trials,
      t(avg_ILI$AVERAGE_ILI)
    )
    
    # Set column names
    colnames(result) <- c("Animal_id", "Date", "Num_trials", as.character(avg_ILI$CONC_STIM))
    
    return(result)
  }
  
  # Check if the path is a directory
  if (dir.exists(path)) {
    file_paths <- list.files(path, pattern = "\\.txt$", full.names = TRUE)
  } else if (file.exists(path)) {
    file_paths <- path
  } else {
    stop("The provided path does not exist.")
  }
  
  # Initialize an empty list to store results
  results <- list()
  
  # Process each file and store results
  if (length(file_paths) > 1) {
    for (file_path in file_paths) {
      results[[file_path]] <- process_file(file_path)
    }
    
    # Combine all results into a single dataframe
    combined_results <- bind_rows(results, .id = "file") %>%
      select(-file)  # Remove the file column if needed
  } else {
    combined_results <- process_file(file_paths)
  }
  
  # Save the combined results to the global environment
  assign("AveResult", combined_results, envir = .GlobalEnv)
  
  # Print a message and return the combined results
  cat("Data has been processed and saved to the global environment as 'AveResult'.\n")
  return(combined_results)
}
